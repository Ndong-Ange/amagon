#!/usr/bin/env python3
"""
Script am√©lior√© pour initialiser toutes les bases de donn√©es SQLite des microservices
G√®re l'installation des d√©pendances, la cr√©ation des migrations et l'initialisation des donn√©es
"""

import os
import subprocess
import sys
from pathlib import Path
import time

class Colors:
    """Couleurs pour l'affichage dans le terminal"""
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

class DatabaseSetup:
    def __init__(self):
        self.root_dir = Path(__file__).parent
        self.services = {
            "API Gateway": {
                "path": "api-gateway",
                "app_name": "gateway",
                "db_file": "gateway_db.sqlite3"
            },
            "Auth Service": {
                "path": "microservices/auth-service",
                "app_name": "auth_app",
                "db_file": "auth_db.sqlite3"
            },
            "Product Service": {
                "path": "microservices/product-service",
                "app_name": "product_app",
                "db_file": "product_db.sqlite3"
            },
            "Order Service": {
                "path": "microservices/order-service",
                "app_name": "order_app",
                "db_file": "order_db.sqlite3"
            },
            "Inventory Service": {
                "path": "microservices/inventory-service",
                "app_name": "inventory_app",
                "db_file": "inventory_db.sqlite3"
            },
            "Seller Service": {
                "path": "microservices/seller-service",
                "app_name": "seller_app",
                "db_file": "seller_db.sqlite3"
            },
            "Store Service": {
                "path": "microservices/store-service",
                "app_name": "store_app",
                "db_file": "store_db.sqlite3"
            }
        }

    def print_colored(self, message: str, color: str = Colors.ENDC):
        """Affiche un message avec une couleur"""
        print(f"{color}{message}{Colors.ENDC}")

    def print_header(self, message: str):
        """Affiche un en-t√™te"""
        self.print_colored(f"\n{'='*70}", Colors.HEADER)
        self.print_colored(f"  {message}", Colors.HEADER + Colors.BOLD)
        self.print_colored(f"{'='*70}", Colors.HEADER)

    def run_command(self, command: str, cwd: str = None, capture_output: bool = True) -> bool:
        """Ex√©cute une commande shell et retourne True si succ√®s"""
        try:
            if isinstance(command, str):
                command = command.split()
            
            result = subprocess.run(
                command,
                cwd=cwd,
                capture_output=capture_output,
                text=True,
                check=True
            )
            
            if not capture_output:
                return True
                
            if result.stdout:
                self.print_colored(f"   Output: {result.stdout.strip()}", Colors.OKCYAN)
            
            return True
            
        except subprocess.CalledProcessError as e:
            self.print_colored(f"‚ùå Erreur lors de l'ex√©cution de '{' '.join(command)}'", Colors.FAIL)
            if e.stderr:
                self.print_colored(f"   Erreur: {e.stderr.strip()}", Colors.FAIL)
            if e.stdout:
                self.print_colored(f"   Output: {e.stdout.strip()}", Colors.WARNING)
            return False
        except FileNotFoundError:
            self.print_colored(f"‚ùå Commande non trouv√©e: {command[0]}", Colors.FAIL)
            return False

    def check_dependencies(self) -> bool:
        """V√©rifie que Python et pip sont install√©s"""
        self.print_header("V√©rification des d√©pendances syst√®me")
        
        # V√©rifier Python
        try:
            result = subprocess.run([sys.executable, "--version"], capture_output=True, text=True)
            python_version = result.stdout.strip()
            self.print_colored(f"‚úÖ {python_version} trouv√©", Colors.OKGREEN)
        except:
            self.print_colored("‚ùå Python non trouv√©", Colors.FAIL)
            return False

        # V√©rifier pip
        try:
            result = subprocess.run([sys.executable, "-m", "pip", "--version"], capture_output=True, text=True)
            pip_version = result.stdout.strip().split('\n')[0]
            self.print_colored(f"‚úÖ {pip_version} trouv√©", Colors.OKGREEN)
        except:
            self.print_colored("‚ùå pip non trouv√©", Colors.FAIL)
            return False

        return True

    def install_dependencies(self) -> bool:
        """Installe les d√©pendances Python pour tous les services"""
        self.print_header("Installation des d√©pendances Python")
        
        success_count = 0
        total_services = len(self.services)
        
        for service_name, config in self.services.items():
            service_path = self.root_dir / config["path"]
            requirements_file = service_path / "requirements.txt"
            
            if not service_path.exists():
                self.print_colored(f"‚ö†Ô∏è  R√©pertoire non trouv√©: {service_path}", Colors.WARNING)
                continue
                
            if not requirements_file.exists():
                self.print_colored(f"‚ö†Ô∏è  requirements.txt non trouv√© pour {service_name}", Colors.WARNING)
                continue
            
            self.print_colored(f"üì¶ Installation des d√©pendances pour {service_name}...", Colors.OKBLUE)
            
            if self.run_command(f"{sys.executable} -m pip install -r requirements.txt", cwd=service_path):
                self.print_colored(f"‚úÖ D√©pendances install√©es pour {service_name}", Colors.OKGREEN)
                success_count += 1
            else:
                self.print_colored(f"‚ùå √âchec de l'installation pour {service_name}", Colors.FAIL)

        self.print_colored(f"\nüìä Installation termin√©e: {success_count}/{total_services} services", Colors.OKBLUE)
        return success_count > 0

    def clean_old_databases(self):
        """Supprime les anciennes bases de donn√©es"""
        self.print_header("Nettoyage des anciennes bases de donn√©es")
        
        for service_name, config in self.services.items():
            service_path = self.root_dir / config["path"]
            db_file = service_path / config["db_file"]
            
            if db_file.exists():
                try:
                    db_file.unlink()
                    self.print_colored(f"üóëÔ∏è  Suppression de {config['db_file']} pour {service_name}", Colors.WARNING)
                except Exception as e:
                    self.print_colored(f"‚ö†Ô∏è  Impossible de supprimer {config['db_file']}: {e}", Colors.WARNING)

    def setup_service_database(self, service_name: str, config: dict) -> bool:
        """Configure la base de donn√©es pour un service sp√©cifique"""
        service_path = self.root_dir / config["path"]
        manage_py = service_path / "manage.py"
        
        if not service_path.exists():
            self.print_colored(f"‚ùå R√©pertoire non trouv√©: {service_path}", Colors.FAIL)
            return False
            
        if not manage_py.exists():
            self.print_colored(f"‚ùå manage.py non trouv√© dans {service_path}", Colors.FAIL)
            return False
        
        self.print_colored(f"üîß Configuration de la base de donn√©es pour {service_name}...", Colors.OKBLUE)
        
        # Supprimer les anciennes migrations
        migrations_dir = service_path / config["app_name"] / "migrations"
        if migrations_dir.exists():
            for migration_file in migrations_dir.glob("*.py"):
                if migration_file.name != "__init__.py":
                    try:
                        migration_file.unlink()
                        self.print_colored(f"   Suppression de {migration_file.name}", Colors.WARNING)
                    except Exception as e:
                        self.print_colored(f"   Impossible de supprimer {migration_file.name}: {e}", Colors.WARNING)
        
        # Cr√©er le r√©pertoire migrations s'il n'existe pas
        migrations_dir.mkdir(exist_ok=True)
        init_file = migrations_dir / "__init__.py"
        if not init_file.exists():
            init_file.touch()
        
        # Makemigrations
        self.print_colored(f"   Cr√©ation des migrations pour {service_name}...", Colors.OKBLUE)
        if not self.run_command(f"{sys.executable} manage.py makemigrations", cwd=service_path):
            self.print_colored(f"‚ùå √âchec de makemigrations pour {service_name}", Colors.FAIL)
            return False
        
        # Migrate
        self.print_colored(f"   Application des migrations pour {service_name}...", Colors.OKBLUE)
        if not self.run_command(f"{sys.executable} manage.py migrate", cwd=service_path):
            self.print_colored(f"‚ùå √âchec de migrate pour {service_name}", Colors.FAIL)
            return False
        
        # V√©rifier que la base de donn√©es a √©t√© cr√©√©e
        db_file = service_path / config["db_file"]
        if db_file.exists():
            db_size = db_file.stat().st_size
            self.print_colored(f"‚úÖ Base de donn√©es cr√©√©e pour {service_name} ({db_size} bytes)", Colors.OKGREEN)
        else:
            self.print_colored(f"‚ö†Ô∏è  Fichier de base de donn√©es non trouv√© pour {service_name}", Colors.WARNING)
        
        return True

    def create_superuser_for_auth_service(self):
        """Cr√©e un superutilisateur pour le service d'authentification"""
        self.print_header("Cr√©ation d'un superutilisateur pour le service d'authentification")
        
        auth_service_path = self.root_dir / "microservices/auth-service"
        
        if not auth_service_path.exists():
            self.print_colored("‚ö†Ô∏è  Service d'authentification non trouv√©", Colors.WARNING)
            return
        
        self.print_colored("üë§ Cr√©ation d'un superutilisateur par d√©faut...", Colors.OKBLUE)
        
        # Cr√©er un script Python pour cr√©er le superutilisateur
        create_superuser_script = """
import os
import django
from django.contrib.auth import get_user_model

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'auth_app.settings')
django.setup()

User = get_user_model()

if not User.objects.filter(username='admin').exists():
    User.objects.create_superuser(
        username='admin',
        email='admin@amagon.com',
        password='admin123'
    )
    print('Superutilisateur cr√©√©: admin / admin123')
else:
    print('Superutilisateur existe d√©j√†')
"""
        
        script_file = auth_service_path / "create_superuser.py"
        try:
            with open(script_file, 'w') as f:
                f.write(create_superuser_script)
            
            if self.run_command(f"{sys.executable} create_superuser.py", cwd=auth_service_path):
                self.print_colored("‚úÖ Superutilisateur cr√©√© (admin / admin123)", Colors.OKGREEN)
            
            # Nettoyer le script temporaire
            script_file.unlink()
            
        except Exception as e:
            self.print_colored(f"‚ùå Erreur lors de la cr√©ation du superutilisateur: {e}", Colors.FAIL)

    def setup_all_databases(self) -> bool:
        """Configure toutes les bases de donn√©es"""
        self.print_header("Configuration des bases de donn√©es SQLite")
        
        success_count = 0
        total_services = len(self.services)
        
        for service_name, config in self.services.items():
            if self.setup_service_database(service_name, config):
                success_count += 1
            time.sleep(1)  # Petite pause entre chaque service
        
        self.print_colored(f"\nüìä Configuration termin√©e: {success_count}/{total_services} bases de donn√©es", Colors.OKBLUE)
        return success_count == total_services

    def run(self) -> bool:
        """Lance la configuration compl√®te"""
        try:
            self.print_colored(f"""
{Colors.HEADER}{Colors.BOLD}
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                üóÑÔ∏è  AMAGON DATABASE SETUP                    ‚ïë
‚ïë              Configuration des bases SQLite                  ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
{Colors.ENDC}""")
            
            # V√©rifier les d√©pendances
            if not self.check_dependencies():
                return False
            
            # Installer les d√©pendances
            if not self.install_dependencies():
                self.print_colored("‚ö†Ô∏è  Certaines d√©pendances n'ont pas pu √™tre install√©es", Colors.WARNING)
            
            # Nettoyer les anciennes bases
            self.clean_old_databases()
            
            # Configurer toutes les bases de donn√©es
            if not self.setup_all_databases():
                return False
            
            # Cr√©er un superutilisateur pour l'auth service
            self.create_superuser_for_auth_service()
            
            self.print_colored(f"\n{Colors.OKGREEN}üéâ Configuration des bases de donn√©es termin√©e avec succ√®s!{Colors.ENDC}")
            self.print_colored(f"{Colors.OKBLUE}Vous pouvez maintenant lancer le projet avec: python run_project.py{Colors.ENDC}")
            
            return True
            
        except Exception as e:
            self.print_colored(f"‚ùå Erreur inattendue: {e}", Colors.FAIL)
            return False

def main():
    """Fonction principale"""
    setup = DatabaseSetup()
    success = setup.run()
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()